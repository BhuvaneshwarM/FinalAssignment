'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.plugin = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var momentFns = Object.keys(_moment2.default.fn);

/**
 * Configure the plugin by attaching moment to the ajv instance and defining the
 * 'moment' custom keyword
 * @param  {Object} options - plugin options
 * @return {Object} keywordSettings
 */
function plugin(options) {
    if (!options || (typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
        throw new Error('AjvMoment#plugin requires options');
    }
    if (!options.ajv) {
        throw new Error('AjvMoment#plugin options requries an \'ajv\' attribute (ajv instance)');
    }
    if (!options.moment) {
        throw new Error('AjvMoment#plugin options requries a \'moment\' attribute (moment.js)');
    }
    var ajv = options.ajv;
    var moment = options.moment;

    ajv.moment = moment;
    var keywordSettings = {
        type: 'string',
        statements: true,
        errors: true,
        inline: inline
    };
    if (ajv) {
        ajv.addKeyword('moment', keywordSettings);
    }
    return keywordSettings;
}

/**
 * Determine whether or not val is an array
 * @param  {*} val
 * @return {Boolean}
 */
function isArray(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
}

/**
 * Ajv inline method
 * @param  {Object} it
 * @param  {String} keyword
 * @param  {*} schema
 * @return {String}
 */
function inline(it, keyword, schema) {
    var data = 'data' + (it.dataLevel || '');
    var valid = 'valid' + it.level;
    var err = 'ajvmErrMsg' + it.level;
    var schemaOptions = (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)) === 'object' ? schema : {};
    var formats = schemaOptions.format || [];
    var validations = schemaOptions.validate || [];

    if (!isArray(validations)) {
        validations = [validations];
    }

    var _validations = validations.map(function (validation) {
        var _validation = {
            test: validation.test,
            value: validation.value
        };
        if (!_validation.test || momentFns.indexOf(_validation.test) === -1) {
            throw new Error('Invalid validation: "test" is required and must be a valid moment function');
        }
        if (!_validation.value) {
            throw new Error('Invalid validation: "value" is required');
        }
        if (!isArray(_validation.value)) {
            _validation.value = [_validation.value];
        }
        _validation.value = _validation.value.map(function (val) {
            var _val = { now: val.now, $data: val.$data, manipulate: val.manipulate };
            if (_val.now !== true && typeof _val.$data !== 'string') {
                _val.now === true;
            } else {
                _val.value = it.util.getData(_val.$data, it.dataLevel, it.dataPathArr);
            }
            if (!isArray(_val.manipulate)) {
                _val.manipulate = [];
            }
            _val.manipulate = _val.manipulate.map(function (manipulation) {
                var manipulationMethod = Object.keys(manipulation)[0];
                if (momentFns.indexOf(manipulationMethod) === -1) {
                    throw new Error('Invalid validation value: unsupported manipulation method specified: ' + manipulationMethod);
                }
                return {
                    method: manipulationMethod,
                    args: isArray(manipulation[manipulationMethod]) ? manipulation[manipulationMethod] : [manipulation[manipulationMethod]]
                };
            });
            return _val;
        });
        return _validation;
    });

    var templ = '\n            var moment = self.moment;\n            ' + valid + ' = true;\n            var ' + err + ' = {\n                keyword: "' + keyword + '",\n                dataPath: "' + (it.dataPathArr[it.dataLevel] || '') + '",\n                schemaPath: "' + it.schemaPath + '",\n                data: ' + data + '\n            };\n\n            var ajvmFormats' + it.level + ' = ' + (formats && formats.length ? JSON.stringify(formats) : '[moment.ISO_8601]') + ';\n            var ajvmStrict' + it.level + ' = ' + (formats && formats.length ? true : false) + ';\n            var d = moment(' + data + ', ajvmFormats' + it.level + ', ajvmStrict' + it.level + ');\n            if (!d.isValid()) {\n                ' + err + '.message = \'should be a valid date' + (formats && formats.length ? ' with format ' + JSON.stringify(formats) : '') + '\';\n                ' + valid + ' = false;\n            }\n        ';

    if (_validations.length) {
        _validations.forEach(function (validation, i) {
            var testResult = 'ajvmTestResult_' + it.level + '_' + i;
            var testVals = '[';
            templ += '\n                    if (' + valid + ' === true) {\n                ';
            validation.value.forEach(function (val, ii) {
                var testVal = 'ajvmTestVal_' + it.level + '_' + i + '_' + ii;
                testVals += testVal + ',';
                if (val.now === true) {
                    templ += '\n                            var ' + testVal + ' = moment();\n                        ';
                } else {
                    templ += '\n                            var ' + testVal + ' = moment(' + val.value + ', ' + (val.format ? JSON.stringify(val.format) : '[moment.ISO_8601]') + ');\n                        ';
                }
                val.manipulate.forEach(function (manipulation) {
                    templ += '\n                            ' + testVal + '.' + manipulation.method + '.apply(' + testVal + ', ' + JSON.stringify(manipulation.args) + ');\n                        ';
                });
            });
            testVals = testVals.slice(0, testVals.length - 1) + ']';
            templ += '\n                        var ' + testResult + ' = d.' + validation.test + '.apply(d, ' + testVals + ');\n                        if (!' + testResult + ') {\n                            ' + err + '.message = \'"' + validation.test + '" validation failed for value(s): \';\n                            ' + testVals + '.forEach(function(c) {\n                                ' + err + '.message += c.toISOString() + \', \';\n                            });\n                            ' + err + '.message = ' + err + '.message.slice(0, -2);\n                            ' + valid + ' = false;\n                        }\n                    }\n                ';
        });
    }

    templ += '\n            if (!' + valid + ') {\n                errors++;\n                if (vErrors) {\n                    vErrors[vErrors.length] = ' + err + ';\n                } else {\n                    vErrors = [' + err + ']\n                }\n            }\n        ';

    return templ;
}

exports.plugin = plugin;